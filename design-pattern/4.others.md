# 其他模式

## 创建者模式

### 单例、工厂

{% page-ref page="1.singleton.md" %}

{% page-ref page="2.factory.md" %}

### 建造者模式 builder

用于组件很多、装配复杂的产品，常与工厂模式配合使用。client只需要与director交互即可。

* builder: 子组件的单独构造
* director: 子组件的装配

```java
class OrbitalModule{}//轨道舱
class Engine{}//发动机
class EscapeTower{]//逃逸塔
public class AirShip{
    private OrbitalModule orbitalModule;
    private Engine engine;
    private EscapeTower escapeTower;
    public void launch(){}
    set(){} & get(){}
}

public interface AirShipBuilder{
    OrbitalModule buildOrbitalModule();
    Engine buildEngine();
    EscapeTower buildEscapeTower();
}
public interface AirShipDirector{
    AirShip directAirShip();
}
public class MyAirShiipBuilder implements AirShipBuilder{
    OrbitalModule buildOrbitalModule(){
        return new OrbitalModule();
    }
    Engine buildEngine(){
        return new Engine();
    }
    EscapeTower buildEscapeTower(){
        return new EscapeTower();
    ]
}
public class MyAirShipDirector{
    private AirShipBuilder builder;
    public MyAirShipDirector(AirShipBuilder builder){
        this.builder = builder;
    }
    AirShip directAirShip(){
        AirShip airShip = new AirShip();
        airShip.setOrbitalModule(builder.buildOrbitalModule());
        airShip.setEngine(builder.buildEngine());
        airShip.serEscapeTower(builder.buildEscapeTower());
        return airShip;
    }
}

public class Client{
    AirShipDirector director = new MyAirShipDirector(new MyAirShiipBuilder());
    AirShip airship = director.directAirShip();
    ship.launch();
}
```

### 原型模式prototype

java的克隆技术，以某个对象为原型，复制一个与原型一样的新对象，稍后再对新对象进行修改。实现方式：

* Cloneable接口
* 重写 clone\(\) 方法

```java
public class Sheep implements Cloneable, Serializable {
    private String name;
    private Date birthday;
    public Sheep(){}
    public Sheep(String name, Data birthday){
        super();
        this.name = name;
        this.birthday = birthday;
    }
    protected Object clone() throws CloneNotSupportedException {
        //return super.clone(); //浅克隆
        Sheep sheep = (Sheep)super.clone();
        sheep.birthday = (Data)this.birthday.clone();
        return sheep; //深克隆
    }
}
//test
Sheep s1 = new Sheep(); Sheep s2 = s1.clone();
```

注意clone与new的区别（性能测试）：

* clone: cloneable接口与 Object 中的 clone\(\) 方法，直接调用本地 C 方法，效率很高
* new: 需要繁琐的数据准备/访问权限，new出的对象值为默认值

需要短时间内创建大量对象，且new的过程比较耗时 -》可以用原型模式。常与工厂模式结合使用。

序列化实现深克隆：

```java
Sheep s1 = new Sheep("Dolly", 123456789123L);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream();
oos.writeObject(s1);
byte[] bytes = bos.toByteArray();

ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
ObjectInputStream ois = new ObjectInputStream(bis);
Sheep s2 = (Sheep)ois.readObject();
s2.setName(); s2.setBirthday();
```

深克隆与浅克隆：

* 浅克隆：属性对象直接复制原型的指针，与原型指向同一个属性对象
* 深克隆：将原型的属性一起复制，与原型的属性对象内容相同，但不是同一个

## 结构型模式

程序结构上实现松耦合，从而扩大整体的类结构，用来解决更大的问题。

### 代理模式

{% page-ref page="3.proxy.md" %}

### 适配器模式 adapter

应用场景：将一个类的接口转换成客户希望的另一种接口，使得因为接口不兼容而不能一起工作的类可以一起工作。将传统键盘使用PS/2接口，笔记本上只有USB接口，可以用适配器进行接口转换。

系统升级时，可能用到大量的适配器。

角色：

* Target 目标接口：客户希望的接口，可以是类、接口
* Adaptee 被适配的类
* Adapter 适配器：通过包装Adaptee，将adaptee转换成目标接口。

实现技术：

* 对象适配器：将 被适配的类 作为 适配器的参数/属性
* 类适配器：适配器类 继承 被适配的类

```java
public interface Target{ //目标接口
    void handleReq();
}
public class Adaptee{ //与目标接口不兼容，需要通过adapter进行转换
    public void request(){}
}
//类适配器
public class Adapter extends Adaptee implements Target{
    public void handleReq(){
        super.request();
    }
}
//对象适配器
public class ObjectAdapter implements Target{
    private Adaptee adaptee;
    public ObjectAdapter(Adaptee adaptee){
        super();
        this.adaptee = adaptee;
    }
    public void handleReq(){
        adaptee.request();
    }
}
public class Client{ //客户需要的是target，已有Adaptee，可以用适配器对adaptee进行转换
    public static void test(Target t){ t.handleReq(); }
    public static void main(String... args){
        Target t = new ObjectAdapter(new Adaptee());
        test(t); // test(new Adapter());
    }
}
```

### 桥接模式 handle and body

桥接模式的核心思想：将除某个维度之外的其他多个维度作为属性，适用于多层继承的结构。变相的实现多重继承。  
应用场景：JDBC驱动、银行日志（日志类型、本地异地）、消息处理（业务类型、发送方式）

角色：

* 抽象化角色 Abstraction
* 扩展抽象化角色 Refined Abstraction
* 实现化角色 Implementor
* 具体实现化角色 Concrete Implementor

场景示例：市场上销售的不同品牌的不同电子产品，可以用两个维度进行分类：产品类型、品牌类型

* 电脑
  * 台式机
    * 联想
    * 戴尔
  * 笔记本
    * 联想
    * 戴尔
  * 平板电脑
    * 联想
    * 戴尔

电脑（品牌）

* * 台式机（品牌）
  * 笔记本（品牌）
  * 平板电脑（品牌）
* 品牌
  * 联想
  * 戴尔

```java
public interface Computer{ void sale(); } //抽象化角色
class Desktop implements Computer{ void sale(){} } //扩展抽象化角色
class Laptop implements Computer{ void sale(){} }
class pad implements Computer{ void sale(){} }
//多重继承，为每个品牌设计实现类——扩展问题、违反单一职责原则
//class LenovoDesktop extends Desktop{ void sale(){} }

//桥接模式：将品牌实现为商品属性
public interface Brand{ void sale(); }   //实现化角色
class Lenovo implements Brand {void sale(){/*销售策略*/} } //具体实现化角色
class Desktop implements Computer{
    Brand brand;
    public Desktop(Brand brand){ this.brand = brand; } 
    void sale(){ brand.sale(); } 
}
```

### 组合模式 composite

将部分与整体的关系用**树形结构**表示，从而使用户可以通过统一的方式处理部分对象与整体对象。

角色：

* 抽象构件 Component
* 叶子构件 Leaf：无子节点
* 容器构件 Composite：包含若干个子节点，子节点类型为抽象构件，既可以是叶子构件，也可以是容器构件（实现递归）

应用案例：操作系统的资源管理器、GUI容器层次图、xml文件解析、Junit单元测试框架。

Junit单元测试框架：

* Test接口
  * TestCase
  * TestUnite

```java
public interface AbstractFile{ //抽象构件
    void killVirus();
}
public File implements AbstractFile{ //叶子构件
    private String name;
    public void killVirus(){}
}
public FileFolder implements AbstractFile{ //容器构件
    private String name;
    private List<AbstractFile> list = new ArrayList<AbstractFile>();
    public void killVirus(){
        for (AbstractFile f : list){
            f.killVirus();
        }
    }
}

public interface Component{void operation();}
public interface LeafComponent extends Component{}
public interface CompositeComponent extends Component{
    void add(Component c);
    void remove(Component c);
}
```

### 装饰模式 decorator

动态地为一个对象增加新的功能。

### 外观模式 

### 享元模式 

## 责任链模式 

## 迭代器模式 

## 中介者模式 

## 命令模式 

## 解释器模式 

## 访问者模式 

## 策略模式 

## 模板方法模式 

## 状态模式 

## 观察者模式 

## 备忘录模式

## 



