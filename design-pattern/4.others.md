# 其他模式

## 创建者模式

### 单例、工厂

{% page-ref page="1.singleton.md" %}

{% page-ref page="2.factory.md" %}

### 建造者模式 builder

用于组件很多、装配复杂的产品，常与工厂模式配合使用。client只需要与director交互即可。

* builder: 子组件的单独构造
* director: 子组件的装配

```java
class OrbitalModule{}//轨道舱
class Engine{}//发动机
class EscapeTower{]//逃逸塔
public class AirShip{
    private OrbitalModule orbitalModule;
    private Engine engine;
    private EscapeTower escapeTower;
    public void launch(){}
    set(){} & get(){}
}

public interface AirShipBuilder{
    OrbitalModule buildOrbitalModule();
    Engine buildEngine();
    EscapeTower buildEscapeTower();
}
public interface AirShipDirector{
    AirShip directAirShip();
}
public class MyAirShiipBuilder implements AirShipBuilder{
    OrbitalModule buildOrbitalModule(){
        return new OrbitalModule();
    }
    Engine buildEngine(){
        return new Engine();
    }
    EscapeTower buildEscapeTower(){
        return new EscapeTower();
    ]
}
public class MyAirShipDirector{
    private AirShipBuilder builder;
    public MyAirShipDirector(AirShipBuilder builder){
        this.builder = builder;
    }
    AirShip directAirShip(){
        AirShip airShip = new AirShip();
        airShip.setOrbitalModule(builder.buildOrbitalModule());
        airShip.setEngine(builder.buildEngine());
        airShip.serEscapeTower(builder.buildEscapeTower());
        return airShip;
    }
}

public class Client{
    AirShipDirector director = new MyAirShipDirector(new MyAirShiipBuilder());
    AirShip airship = director.directAirShip();
    ship.launch();
}
```

### 原型模式prototype

java的克隆技术，以某个对象为原型，复制一个与原型一样的新对象，稍后再对新对象进行修改。实现方式：

* Cloneable接口
* 重写 clone\(\) 方法

```java
public class Sheep implements Cloneable, Serializable {
    private String name;
    private Date birthday;
    public Sheep(){}
    public Sheep(String name, Data birthday){
        super();
        this.name = name;
        this.birthday = birthday;
    }
    protected Object clone() throws CloneNotSupportedException {
        //return super.clone(); //浅克隆
        Sheep sheep = (Sheep)super.clone();
        sheep.birthday = (Data)this.birthday.clone();
        return sheep; //深克隆
    }
}
//test
Sheep s1 = new Sheep(); Sheep s2 = s1.clone();
```

注意clone与new的区别（性能测试）：

* clone: cloneable接口与 Object 中的 clone\(\) 方法，直接调用本地 C 方法，效率很高
* new: 需要繁琐的数据准备/访问权限，new出的对象值为默认值

需要短时间内创建大量对象，且new的过程比较耗时 -》可以用原型模式。常与工厂模式结合使用。

序列化实现深克隆：

```java
Sheep s1 = new Sheep("Dolly", 123456789123L);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream();
oos.writeObject(s1);
byte[] bytes = bos.toByteArray();

ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
ObjectInputStream ois = new ObjectInputStream(bis);
Sheep s2 = (Sheep)ois.readObject();
s2.setName(); s2.setBirthday();
```

深克隆与浅克隆：

* 浅克隆：属性对象直接复制原型的指针，与原型指向同一个属性对象
* 深克隆：将原型的属性一起复制，与原型的属性对象内容相同，但不是同一个

## 结构型模式

程序结构上实现松耦合，从而扩大整体的类结构，用来解决更大的问题。

### 代理模式

{% page-ref page="3.proxy.md" %}

### 适配器模式 adapter

应用场景：将一个类的接口转换成客户希望的另一种接口，使得因为接口不兼容而不能一起工作的类可以一起工作。将传统键盘使用PS/2接口，笔记本上只有USB接口，可以用适配器进行接口转换。

系统升级时，可能用到大量的适配器。

角色：

* Target 目标接口：客户希望的接口，可以是类、接口
* Adaptee 被适配的类
* Adapter 适配器：通过包装Adaptee，将adaptee转换成目标接口。

实现技术：

* 对象适配器：将 被适配的类 作为 适配器的参数/属性
* 类适配器：适配器类 继承 被适配的类

```java
public interface Target{ //目标接口
    void handleReq();
}
public class Adaptee{ //与目标接口不兼容，需要通过adapter进行转换
    public void request(){}
}
//类适配器
public class Adapter extends Adaptee implements Target{
    public void handleReq(){
        super.request();
    }
}
//对象适配器
public class ObjectAdapter implements Target{
    private Adaptee adaptee;
    public ObjectAdapter(Adaptee adaptee){
        super();
        this.adaptee = adaptee;
    }
    public void handleReq(){
        adaptee.request();
    }
}
public class Client{ //客户需要的是target，已有Adaptee，可以用适配器对adaptee进行转换
    public static void test(Target t){ t.handleReq(); }
    public static void main(String... args){
        Target t = new ObjectAdapter(new Adaptee());
        test(t); // test(new Adapter());
    }
}
```

### 桥接模式 handle and body

桥接模式的核心思想：将除某个维度之外的其他多个维度作为属性，适用于多层继承的结构。变相的实现多重继承。  
应用场景：JDBC驱动、银行日志（日志类型、本地异地）、消息处理（业务类型、发送方式）

角色：

* 抽象化角色 Abstraction
* 扩展抽象化角色 Refined Abstraction
* 实现化角色 Implementor
* 具体实现化角色 Concrete Implementor

场景示例：市场上销售的不同品牌的不同电子产品，可以用两个维度进行分类：产品类型、品牌类型

* 电脑
  * 台式机
    * 联想
    * 戴尔
  * 笔记本
    * 联想
    * 戴尔
  * 平板电脑
    * 联想
    * 戴尔

电脑（品牌）

* * 台式机（品牌）
  * 笔记本（品牌）
  * 平板电脑（品牌）
* 品牌
  * 联想
  * 戴尔

```java
public interface Computer{ void sale(); } //抽象化角色
class Desktop implements Computer{ void sale(){} } //扩展抽象化角色
class Laptop implements Computer{ void sale(){} }
class pad implements Computer{ void sale(){} }
//多重继承，为每个品牌设计实现类——扩展问题、违反单一职责原则
//class LenovoDesktop extends Desktop{ void sale(){} }

//桥接模式：将品牌实现为商品属性
public interface Brand{ void sale(); }   //实现化角色
class Lenovo implements Brand {void sale(){/*销售策略*/} } //具体实现化角色
class Desktop implements Computer{
    Brand brand;
    public Desktop(Brand brand){ this.brand = brand; } 
    void sale(){ brand.sale(); } 
}
```

### 组合模式 composite

将部分与整体的关系用**树形结构**表示，从而使用户可以通过统一的方式处理部分对象与整体对象。

角色：

* 抽象构件 Component
* 叶子构件 Leaf：无子节点
* 容器构件 Composite：包含若干个子节点，子节点类型为抽象构件，既可以是叶子构件，也可以是容器构件（实现递归）

应用案例：操作系统的资源管理器、GUI容器层次图、xml文件解析、Junit单元测试框架。

Junit单元测试框架：

* Test接口
  * TestCase
  * TestUnite

```java
public interface AbstractFile{ //抽象构件
    void killVirus();
}
public File implements AbstractFile{ //叶子构件
    private String name;
    public void killVirus(){}
}
public FileFolder implements AbstractFile{ //容器构件
    private String name;
    private List<AbstractFile> list = new ArrayList<AbstractFile>();
    public void killVirus(){
        for (AbstractFile f : list){
            f.killVirus();
        }
    }
}

public interface Component{void operation();}
public interface LeafComponent extends Component{}
public interface CompositeComponent extends Component{
    void add(Component c);
    void remove(Component c);
}
```

### 装饰模式 decorator

动态地为一个对象增加新的功能。用于替代继承技术，用对象的关联关系代替继承关系

角色：

* Component 抽象构件，真实对象与装饰对象的相同接口
* Concrete Component 具体构件，真实对象/被装饰对象，继承自/实现了Component
* Decorator 装饰角色，继承自/实现了Component，持有component的引用，用于对具体构件附加新功能
* Concrete Decorator 具体装饰角色，继承自Decorator，给构件对象增加新的功能

```java
public interface ICar{ void move(); } //Component
class Car implements ICar{  //Concrete Component
    public void move(){ System.out.println("Car.move()"); }
}
class SuperCar implements ICar { //Decorator
    protected ICar car; //Decorator持有的Component组件
    public void move(){
        car.move();
    }
}
class FlyCar extends SuperCar{ //Concrete Decorator
    protected ICar car;
    public void move(){ 
        car.move(); 
        fly();
    }
    public void fly() {} //为组件添加的新功能
}
```

IO流是典型的装饰模式应用。XXXWrapper也是典型的装饰模式。

```java
Reader r = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
```

优点：降低耦合  
缺点：调试复杂

桥接模式与装饰模式：

* 桥接模式：维度变化
* 装饰模式：功能变化

### 外观模式  Facade 

迪米特法则（最少知识原则）：一个软件实体应当尽可能的少与其他实体发生相互作用。

外观模式为子系统提供统一的入口，方便用户对子系统的访问。

应用案例：注册公司

1. 工商局：注册公司名（不与其他相似），办理营业执照
2. 质检局：办理组织机构代码证
3. 税务局：办理税务等级证
4. 银行开户

```java
class GongShangJu {
    public boolean checkName(){}
}
class ZhiJianJu {
    public OrgCodeCertificate obtainOrgCodeCertificate(){}
}
Class ShuiWuJu {
    public TaxCertificate obtainTaxCertificate(){}
}
Class Band {
    public account newAccount(){}
}

public Register{ //外观类
    public void register(){
        (new GongShangJu()).checkName();
        (new ZhiJianJu()).obtainOrgCodeCertificate();
        (new ShuiWuJu()).obtainTaxCertificate();
        (new Bank()).newAccount();
    }
}
```

### 享元模式 FlyWeight\(蝇量级\)

应用场景：内存属于稀缺资源，不能随便浪费；如果由很多个完全相同或相似的对象，可以通过享元模式节省内存。

核心思想是以共享的方式，高效的支持大量细粒度对象的重用。

如何实现共享：区分内部状态和外部状态

* 内部状态：可以共享，不随环境变化而改变
* 外部状态：不能共享，会随环境变化而改变

角色：

* FlyweightFactory 享元工厂类，用于创建与管理享元对象\(享元池\)，享元池一般设计成键值对
* Flyweight 抽象享元类
* ConcreteFlyweight 具体享元类
* UnsharedConcreteFlyweight 非共享享元类

优点：减少内存消耗  
缺点：运行复杂、运行时间长  
本质是以时间换空间。

应用案例：线程池、数据库连接池、字符串常量池

棋子  
\|——位置（外部状态）  
\|——颜色 - \  
\|——形状 - --- 内部状态  
\|——大小 - /

```java
public abstract class ChessFlyWeight{ // 抽象享元类
    protected Color color;
    protected float redis;
    public ChessFlyWeight(Color color, float r){ this.color = color; this.redis = r; }
}
public class Coordinate { //非共享享元类
    int x, y;
    public Coordinate(int x, int y){
        super();
        this.x = x;
        this.y = y;
    }
}
public class ConcreteChess extends ChessFlyWeight{ //具体享元类
    public ConcreteChess(Color c){
        super(c);
    }
    public void display(Coordinate c){
        System.out.println("" + this.color + " ("+c.x+", "+c.y+") " );
    }
}
public class ChessFactory{ //享元工厂类
    private static Map<int, ChessFlyWeight> map = new HashMap<int, ChessflyWeight>();
    public static ChessflyWeight getChess(int index){
        if(map.get(index) == null){ 
            map.put(index, new ConcreteChess(new color()) );
        }
        return map.get(index);       
    }
}
public class Client{
    public static void main(String... args){
        ChessFlyWeight chess1 = ChessFactory.get(1);
        chess1.display(new Coordiante(2, 5));
    }
}
```

## 行为型模式

关注系统中对象之间的交互，研究系统在运行时对象之间的互相通信和协作，进一步明确对象职责。

### 责任链模式  chain of responsibility

将能处理同一类请求的对象连成一条链。本质是对 if-else 多分支语句的封装。

角色：

* Handler 抽象处理者
* Concrete handler 具体处理者

应用场景：轮流出牌、接力比赛、奖学金审批、公文审批等。

案例：请假流程审批

```java
public class Request{
    String empName;
    int leaveDays;
    String reason;
}
public abstract class Leader{
    protected String name;
    protected Handler nextLeader = null;
    public Leader(String name){ this.name = name; }
    public void setNextLeader(Leader nextLeader){this.nextLeader = nextLeader;}
    public void handle(Request req);
}
public class Director extends Leader{ //主任
    public Director(String name){super(name); }
    public void handle(Request req){
        if (req.leaveDays < 3){
            System.out.println("Director approve!");
        }else{
            if(this.nextLeader != null){
                this.nextLeader.handle(req);
            }else{
                System.out.println("Director not approved!");
            }
        }
    }
}
public class Maneger{ //经理
    public Manager(String name){super(name);}
    public void handle(Request req){
        if (req.leaveDays < 10 ){
            System.out.println("Manager approve!");
        }else{
            if(this.nextLeader != null){
                this.nextLeader.handle(req);
            }else{
                System.out.println("Manager approve！");
            }
        }
    }
}
public class Test{
    public static void main(String... args){
        Leader a = new Director("zhang san");
        Leader b = new Manager("li si");
        a.setNextLeader(b);
        Request req = new Request("wang wu", 7, "病假");
        a.handle(req);
    }
}
```

* java 中的异常机制，事件的处理
* Servlet 中，过滤器的链式处理
* Struts 2 中，拦截器的调用
* javascript 中，事件的冒泡和捕获机制
* Tomcat中的应用：filter、容器

### 迭代器模式 Iterator / Cursor模式

提供一种可以遍历聚合对象的方式。

* 聚合对象：存储数据
* 迭代器：遍历数据

角色：

* Iterator
* Concrete iterator
* Aggregate
* Concrete aggregate

```java
public interface MyIterator{ // iterator
    void next();
    boolean hasNext();
    Object getCurrentObject();
}
public class ConcreteAggregate{ 
    private List<Object> list = new ArrayList<Object>();
    public MyIterator createIterator(){
        return new ConcreteIterator();
    }
    private class ConcreteIterator implements MyIterator{ //具体迭代器对象
        private int cursor;
        void next(){
            if(cursor < list.size()){ cursor++; }
        }
        boolean hasNext(){
            if(cursor < list.size()){ return true; 
            } else {retrun false; }
        }
        Object getCurrentObject(){
            return list.get(cursor);
        }
    }
}
```

开发应用：java容器中常见。

### 中介者模式 Mediator

### 命令模式 

### 解释器模式 

不太常用，一般用在变成语言的解释器中。

### 访问者模式 

### 策略模式 

### 模板方法模式 

### 状态模式 

### 观察者模式 

### 备忘录模式

## 



