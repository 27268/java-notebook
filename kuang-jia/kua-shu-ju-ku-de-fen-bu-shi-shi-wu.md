---
description: 图灵学院
---

# 跨数据库的分布式事务

分布式事务——跨数据库\(一个方法，操作两个数据库\) 能不能用spring的transaction注解能不能解决？不能\(why?\)

解决办法：2pc两阶段提交协议。1阶段：执行完sql，不要立即提交，先告诉协调器，2阶段：协调器通知数据库，提交修改。

问题：2阶段提交失败怎么办？协调器重试，重新提交若干次，若依然失败，记录到日志，建定时任务，再次提交，若再次失败，可能需要人工介入。——提高分布式事务的成功概率。

两阶段提交如何处理高并发？

2阶段现在应用不多了，但还是可以用来实现一些关键业务。

2pc   xa/jta规范 ——试探执行

实现框架：

atomikos

1. 创建atomikos数据源，连接到mysql数据库，\(封装原生jdbc连接\)，两个！因为数据库操作跨库。

2. 创建UserTransaction事务，tx.begin\(\), 执行sql语句，tx.commit\(\). 即可。

commit是精华！！

XA是jdk提供的两阶段提交接口2pc

两个连接的prepare\(\)都成功，两个都提交，若有一个失败，回滚。

微服务架构 跨\(jvm\)系统的事务的结论方法：两阶段思想

CAP理论：一致性，可用性，分区容错

Base理论：基本可用ba，软状态\(中间状态\)s，最终一致e

柔性事务 tcc\(try confirm cancel\)两阶段补偿型方案

T 预留资源try：修改订单状态为更新中，冻结库存，预加积分\(数据库中有预加积分字段\)，创建草稿状态出库单；

C 确认资源confirm/cancel：t阶段成功的话，调用confirm api, 修改订单状态为已支付，扣库存，加积分，正式出库单，t阶段有失败的话，调用cancel api，回滚，修改订单状态为已提交。

存在中间协调者负责调用t c c的api.

tcc与2pc的本质区别：2pc是一个大事务，在高并发环境中可用性差；tcc解决大事务问题：两个阶段之间不需要锁库\(因为t阶段已经修改了数据库，预加积分字段，预减库存字段，草稿状态的出库单都已经处理好了，除了订单服务的锁之外，其他的锁都是可以释放的，在高并发环境下是有优势的\)

2pc强一致性，资源层面锁

Tcc最终一致性，应用层面锁，

Tcc实现框架：tcc-transaction, byteTCC, lcn,

实现最终一致性的方案：tcc, mq.

